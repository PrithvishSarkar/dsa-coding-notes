#include <bits/stdc++.h>

using namespace std;

class Node {
  public: int data;
  Node * next;

  Node(int data) {
    this -> data = data;
    next = nullptr;
  }
};

class List {
  Node * head;
  Node * tail;
  public:
    List() {
      head = nullptr;
      tail = nullptr;
    }
  void insert(int);
  Node * getHead() {
    return head;
  }
};

void List::insert(int data) {
  Node * ptr = new Node(data);
  if (head == nullptr && tail == nullptr) {
    head = ptr;
    tail = ptr;
    return;
  }
  tail -> next = ptr;
  tail = ptr;
}

void input(List & LL, int n) {
  while (n) {
    int element;
    cin >> element;
    LL.insert(element);
    n--;
  }
}

void print(Node * head) {
  Node * temp = head;
  while (temp != nullptr) {
    cout << temp -> data << " ";
    temp = temp -> next;
  }
  cout << endl;
}

// Time Complexity is O(N) and Space Complexity is O(1).
Node * sortTrinaryLL(Node * head) {
  Node * zeroHead = nullptr; // Points to the 1st zero.
  Node * zeroPtr = nullptr;
  Node * oneHead = nullptr; // Points to the 1st one.
  Node * onePtr = nullptr;
  Node * twoHead = nullptr; // Points to the 1st two.
  Node * twoPtr = nullptr;

  Node * temp = head; // Traversing pointer.

  while (temp != nullptr) {
    int value = temp -> data;
    switch (value) {
      case 0:
        if (zeroHead == nullptr && zeroPtr == nullptr) {
          zeroHead = temp;
          zeroPtr = temp;
        } else {
          zeroPtr -> next = temp;
          zeroPtr = temp;
        }
        temp = temp -> next;
        break;
      case 1:
        if (oneHead == nullptr && onePtr == nullptr) {
          oneHead = temp;
          onePtr = temp;
        } else {
          onePtr -> next = temp;
          onePtr = temp;
        }
        temp = temp -> next;
        break;
      case 2:
        if (twoHead == nullptr && twoPtr == nullptr) {
          twoHead = temp;
          twoPtr = temp;
        } else {
          twoPtr -> next = temp;
          twoPtr = temp;
        }
        temp = temp -> next;
        break;
      default:
        break;
    }
  }
  if (zeroPtr != nullptr) zeroPtr->next = oneHead;
  if (onePtr != nullptr) onePtr->next = twoHead;
  if (twoPtr != nullptr) twoPtr->next = nullptr;
  
  return zeroHead;
}

int main() {
  int size;
  cin >> size;
  List LL;
  input(LL, size);

  Node * head = sortTrinaryLL(LL.getHead());
  print(head);
  return 0;
}